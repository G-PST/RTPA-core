#[cfg(test)]
mod tests {
    use crate::ieee_c37_118::frames::{DataFrame, FrameType};
    use crate::ieee_c37_118::frames_v2::{
        CommandFrame2011, ConfigurationFrame1and2_2011, DataFrame2011, PMUConfigurationFrame2011,
        PMUFrameType, PMUValues, PrefixFrame2011,
    };
    use crate::ieee_c37_118::models::DataValue;
    use crate::ieee_c37_118::utils::{calculate_crc, validate_checksum};
    use std::fs;
    use std::path::Path;

    // Helper function to read test data files
    fn read_hex_file(file_name: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let path = Path::new("tests/test_data").join(file_name);
        let content = fs::read_to_string(path)?;

        // Remove any whitespace and newlines
        let hex_string: String = content.chars().filter(|c| !c.is_whitespace()).collect();

        // Ensure we have an even number of hex characters
        if hex_string.len() % 2 != 0 {
            return Err("Invalid hex string: odd number of characters".into());
        }

        // Convert pairs of hex characters to bytes
        let mut result = Vec::with_capacity(hex_string.len() / 2);
        let mut i = 0;
        while i < hex_string.len() {
            let byte_str = &hex_string[i..i + 2];
            let byte = u8::from_str_radix(byte_str, 16)?;
            result.push(byte);
            i += 2;
        }

        Ok(result)
    }

    #[test]
    fn test_calculate_crc_standard_values() {
        // Test values from Table B.1 of IEEE C37.118.2-2011 standard
        let test_cases = [
            (vec![0x41, 0x42, 0x43, 0x44], 0xBFFA),
            (vec![0x31, 0x32, 0x33, 0x34, 0x35, 0x36], 0x2EF4),
            (vec![0x61, 0x62, 0x63], 0x514A),
        ];

        for (input, expected_crc) in test_cases.iter() {
            let calculated_crc = calculate_crc(input);
            assert_eq!(
                calculated_crc, *expected_crc,
                "CRC mismatch for input: {:?}",
                input
            );
        }
    }

    #[test]
    fn test_crc_validation() {
        let files = ["cmd_message.bin", "config_message.bin", "data_message.bin"];

        for file in files.iter() {
            let buffer = read_hex_file(file).unwrap();
            let frame_size = u16::from_be_bytes([buffer[2], buffer[3]]) as usize;
            let calculated_crc = calculate_crc(&buffer[..frame_size - 2]);
            let frame_crc = u16::from_be_bytes([buffer[frame_size - 2], buffer[frame_size - 1]]);

            assert_eq!(calculated_crc, frame_crc, "CRC mismatch for file: {}", file);
        }
    }

    #[test]
    fn test_command_frame_to_hex() {
        // Create a CommandFrame2011 struct with the expected values
        let command_frame = CommandFrame2011 {
            prefix: PrefixFrame2011 {
                sync: 0xAA41,
                framesize: 18,
                idcode: 7734,
                soc: 1149591600,
                fracsec: 252428240, //byteorder=bigendian
            },
            command: 2,
            extframe: None,
            chk: 0, //to be filled by to_hex method.
        };

        // Convert the struct to a Vec<u8>
        let frame_bytes = command_frame.to_hex();

        // Read the hex file
        let file_bytes = read_hex_file("cmd_message.bin").unwrap();

        // Compare the generated bytes with the file contents
        assert_eq!(
            frame_bytes, file_bytes,
            "Generated command frame does not match the file contents"
        );
    }

    // Test for create_command_frame function
    #[test]
    fn test_create_command_frame() {
        let buffer = read_hex_file("cmd_message.bin").unwrap();
        let result = crate::ieee_c37_118::parse_command_frame(&buffer);

        assert!(result.is_ok(), "Failed to create command frame");
        let command_frame = result.unwrap();

        assert_eq!(command_frame.command(), 2);
        assert_eq!(command_frame.id_code(), 7734);
    }

    // Test for create_configuration_frame function
    #[test]
    fn test_create_configuration_frame() {
        let buffer = read_hex_file("config_message.bin").unwrap();
        let result = crate::ieee_c37_118::parse_configuration_frame(&buffer);

        assert!(result.is_ok(), "Failed to create configuration frame");
        let config_frame = result.unwrap();

        assert_eq!(config_frame.num_pmu(), 1);
        assert_eq!(config_frame.id_code(), 7734);
        assert_eq!(config_frame.time_base(), 1000000);
    }

    // Test for create_data_frame function
    // TODO
    #[test]
    fn test_create_data_frame() {
        // First get the config frame
        let config_buffer = read_hex_file("config_message.bin").unwrap();
        let config_result = crate::ieee_c37_118::parse_configuration_frame(&config_buffer);
        assert!(
            config_result.is_ok(),
            "Failed to create configuration frame"
        );
        let config_frame = config_result.unwrap();

        // Now test the data frame
        let data_buffer = read_hex_file("data_message.bin").unwrap();
        let result = crate::ieee_c37_118::parse_data_frame(&data_buffer, config_frame.as_ref());

        assert!(result.is_ok(), "Failed to create data frame");
        let data_frame = result.unwrap();

        assert_eq!(data_frame.id_code(), 7734);

        // Test accessing some values
        if let Some(value) = data_frame.get_value("Station A_7734_FREQ", config_frame.as_ref()) {
            match value {
                DataValue::Integer(freq) => assert_eq!(freq, 2500),
                _ => panic!("Expected integer value for frequency"),
            }
        } else {
            panic!("Failed to get frequency value");
        }
    }

    // Additional tests for specific implementation details
    #[test]
    fn test_parse_config_frame() {
        let buffer = read_hex_file("config_message.bin").unwrap();
        let result = crate::ieee_c37_118::parse_configuration_frame(&buffer);

        assert!(result.is_ok(), "Failed to parse configuration frame");

        let config_frame = result.unwrap();

        // Downcast to the concrete type to access specific fields
        let concrete_frame = config_frame
            .as_any()
            .downcast_ref::<ConfigurationFrame1and2_2011>()
            .unwrap();

        // Add assertions to verify the parsed data
        println!("Config frame prefix: {:?}", concrete_frame.prefix);
        assert_eq!(concrete_frame.prefix.framesize, 454);
        assert_eq!(concrete_frame.prefix.idcode, 7734);
        assert_eq!(concrete_frame.time_base, 1000000);
        assert_eq!(concrete_frame.num_pmu, 1);
        assert_eq!(concrete_frame.data_rate, 30);

        // Verify PMU configuration
        let pmu_config = &concrete_frame.pmu_configs[0];
        assert_eq!(pmu_config.idcode, 7734);
        assert_eq!(pmu_config.format, 4);
        assert_eq!(pmu_config.phnmr, 4);
        assert_eq!(pmu_config.annmr, 3);
        assert_eq!(pmu_config.dgnmr, 1);

        // Verify CRC
        let calculated_crc = calculate_crc(&buffer[..buffer.len() - 2]);
        assert_eq!(
            calculated_crc, concrete_frame.chk,
            "CRC mismatch in configuration frame"
        );
    }

    #[test]
    fn test_pmu_config_serialization() {
        // Create a sample PMU configuration
        let config_buffer = read_hex_file("config_message.bin").unwrap();
        let config_frame = crate::ieee_c37_118::parse_configuration_frame(&config_buffer).unwrap();
        let concrete_frame = config_frame
            .as_any()
            .downcast_ref::<ConfigurationFrame1and2_2011>()
            .unwrap();
        let pmu_config = &concrete_frame.pmu_configs[0];

        // Serialize to JSON
        let json = serde_json::to_string_pretty(pmu_config).unwrap();
        println!("Serialized PMU Config:\n{}", json);

        // Parse the JSON back into a Value for verification
        let parsed: serde_json::Value = serde_json::from_str(&json).unwrap();

        // Verify specific fields
        assert_eq!(parsed["idcode"], 7734);
        assert_eq!(parsed["phnmr"], 4);
        assert_eq!(parsed["annmr"], 3);
        assert_eq!(parsed["dgnmr"], 1);

        // Verify station name is properly decoded
        assert_eq!(parsed["stn"], "Station A");

        // Verify channel names are present and correct
        let channels = parsed["channels"].as_array().unwrap();
        assert!(!channels.is_empty());

        // Verify format flags
        let format_flags = &parsed["format_flags"];
        assert_eq!(format_flags["freq_dfreq_float"], false);
        assert_eq!(format_flags["analog_float"], true);
        assert_eq!(format_flags["phasor_float"], false);
        assert_eq!(format_flags["phasor_polar"], false);

        // Verify computed properties
        assert_eq!(parsed["is_polar"], false);
    }
}
