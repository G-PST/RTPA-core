#![allow(unused)]
use std::fs;
use std::path::Path;

fn read_hex_file(file_name: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    let path = Path::new("tests/test_data").join(file_name);
    let content = fs::read_to_string(path)?;
    let hex_string: String = content.chars().filter(|c| !c.is_whitespace()).collect();

    hex_string
        .as_bytes()
        .chunks(2)
        .map(|chunk| {
            let hex_byte = std::str::from_utf8(chunk).unwrap();
            u8::from_str_radix(hex_byte, 16).map_err(|e| e.into())
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use pmu::frame_parser::{parse_config_frame_1and2, parse_data_frames};
    use pmu::frames::{
        calculate_crc, ConfigurationFrame1and2_2011, DataFrame2011, PMUConfigurationFrame2011,
        PMUFrameType, PMUValues, PrefixFrame2011,
    };

    #[test]
    fn test_calculate_crc_standard_values() {
        // Test values from Table B.1 of IEEE C37.118.2-2011 standard
        let test_cases = [
            (vec![0x41, 0x42, 0x43, 0x44], 0xBFFA),
            (vec![0x31, 0x32, 0x33, 0x34, 0x35, 0x36], 0x2EF4),
            (vec![0x61, 0x62, 0x63], 0x514A),
        ];

        for (input, expected_crc) in test_cases.iter() {
            let calculated_crc = calculate_crc(input);
            assert_eq!(
                calculated_crc, *expected_crc,
                "CRC mismatch for input: {:?}",
                input
            );
        }
    }
    #[test]
    fn test_crc_validation() {
        let files = ["cmd_message.bin", "config_message.bin", "data_message.bin"];

        for file in files.iter() {
            let buffer = super::read_hex_file(file).unwrap();
            let frame_size = u16::from_be_bytes([buffer[2], buffer[3]]) as usize;
            let calculated_crc = calculate_crc(&buffer[..frame_size - 2]);
            let frame_crc = u16::from_be_bytes([buffer[frame_size - 2], buffer[frame_size - 1]]);

            assert_eq!(calculated_crc, frame_crc, "CRC mismatch for file: {}", file);
        }
    }

    #[test]
    fn test_command_frame_to_hex() {
        use pmu::frames::CommandFrame2011;

        // Create a CommandFrame2011 struct with the expected values
        let command_frame = CommandFrame2011 {
            prefix: PrefixFrame2011 {
                sync: 0xAA41,
                framesize: 18,
                idcode: 7734,
                soc: 1149591600,
                fracsec: 252428240, //byteorder=bigendian
            },
            command: 2,
            extframe: None,
            chk: 0, //to be filled by to_hex method.
        };

        // Convert the struct to a Vec<u8>
        let frame_bytes = command_frame.to_hex();

        // Read the hex file
        let file_bytes = super::read_hex_file("cmd_message.bin").unwrap();

        // Compare the generated bytes with the file contents
        assert_eq!(
            frame_bytes, file_bytes,
            "Generated command frame does not match the file contents"
        );
    }

    // Tests the parse_config_frame1and2_2011 function
    // Uses test data from the IEEE C37.118.2 2011 standard.
    // Tests that certain values are parsed correctly.
    #[test]
    fn test_parse_config_frame() {
        let buffer = super::read_hex_file("config_message.bin").unwrap();
        let result = parse_config_frame_1and2(&buffer);

        assert!(result.is_ok(), "Failed to parse configuration frame");

        let config_frame = result.unwrap();

        // Add assertions to verify the parsed data
        println!("Config frame prefix: {:?}", config_frame.prefix);
        assert_eq!(config_frame.prefix.framesize, 454);
        assert_eq!(config_frame.prefix.idcode, 7734);
        assert_eq!(config_frame.time_base, 1000000);
        assert_eq!(config_frame.num_pmu, 1);
        assert_eq!(config_frame.data_rate, 30);

        // Verify PMU configuration
        let pmu_config = &config_frame.pmu_configs[0];
        //assert_eq!(pmu_config.stn, *b"Station A        ");
        assert_eq!(pmu_config.idcode, 7734);
        assert_eq!(pmu_config.format, 4);
        assert_eq!(pmu_config.phnmr, 4);
        assert_eq!(pmu_config.annmr, 3);
        assert_eq!(pmu_config.dgnmr, 1);

        // TODO Add more assertions as needed to verify other fields
        // Verify CRC
        let calculated_crc = calculate_crc(&buffer[..buffer.len() - 2]);
        assert_eq!(
            calculated_crc, config_frame.chk,
            "CRC mismatch in configuration frame"
        );
    }

    #[test]
    fn test_parse_data_frame() {
        // First, parse the configuration frame
        let config_buffer = super::read_hex_file("config_message.bin").unwrap();
        let config_result = parse_config_frame_1and2(&config_buffer);
        assert!(config_result.is_ok(), "Failed to parse configuration frame");
        let config_frame = config_result.unwrap();

        let pmu_config = &config_frame.pmu_configs[0];
        println!("phnmr: {}", pmu_config.phnmr);
        println!("annmr: {}", pmu_config.annmr);
        println!("phasor_usize: {}", pmu_config.phasor_size());
        println!("analog_usize: {}", pmu_config.analog_size());
        println!("freq_dfreq_usize: {}", pmu_config.freq_dfreq_size());

        // Now, parse the data frame
        let data_buffer = super::read_hex_file("data_message.bin").unwrap();
        let data_result = parse_data_frames(&data_buffer, &config_frame);
        assert!(data_result.is_ok(), "Failed to parse data frame");
        let data_frame = data_result.unwrap();

        // Add assertions to verify the parsed data
        // All test data is based on Table D.1 of IEEE C37.118.2 - 2011
        assert_eq!(data_frame.prefix.framesize, 52);
        assert_eq!(data_frame.prefix.idcode, 7734);
        assert_eq!(data_frame.prefix.soc, 1149580800);
        assert_eq!(data_frame.prefix.fracsec, 16817);

        // Verify PMU data
        assert_eq!(data_frame.data.len(), 1);
        //let pmu_data = &data_frame.data[0];

        //assert_eq!(pmu_data.stat, 0x0000);
        // Verify PMU data
        let pmu_data = match &data_frame.data[0] {
            PMUFrameType::Fixed(data) => data,
            _ => panic!("Expected PMUDataFrameFloating"),
        };

        assert_eq!(pmu_data.stat, 0x0000);
        // Verify phasors, frequency, dfreq, analog, and digital values
        // Note: These assertions might need adjustment based on your exact parsing logic
        assert_eq!(pmu_data.phasors.len(), 16); // Size in Bytes
        assert_eq!(pmu_data.freq, 2500);
        assert_eq!(pmu_data.dfreq, 0);
        assert_eq!(pmu_data.analog.len(), 12); // Size in Bytes
        assert_eq!(pmu_data.digital.len(), 2); // Size in Bytes

        let phasor_values = match &data_frame.data[0] {
            PMUFrameType::Fixed(data) => data.parse_phasors(pmu_config),
            PMUFrameType::Floating(data) => data.parse_phasors(pmu_config),
        };

        let is_polar = pmu_config.is_phasor_polar();
        assert_eq!(is_polar, false);

        // Test Phasor values
        assert_eq!(phasor_values[0], PMUValues::Fixed(vec![14635, 0]));
        assert_eq!(phasor_values[1], PMUValues::Fixed(vec![-7318, -12676]));
        assert_eq!(phasor_values[2], PMUValues::Fixed(vec![-7318, 12675]));
        assert_eq!(phasor_values[3], PMUValues::Fixed(vec![1092, 0]));

        // Test Analog Values
        let analog_values = match &data_frame.data[0] {
            PMUFrameType::Fixed(data) => data.parse_analogs(pmu_config),
            PMUFrameType::Floating(data) => data.parse_analogs(pmu_config),
        };

        assert_eq!(
            analog_values,
            PMUValues::Float(vec![100.0, 1000.0, 10000.0])
        );
        // Test Digital Values
        let digital_values = match &data_frame.data[0] {
            PMUFrameType::Fixed(data) => data.parse_digitals(),
            PMUFrameType::Floating(data) => data.parse_digitals(),
        };

        println!("Digital Values: {:016b}", digital_values[0]); // Display as 16-bit binary

        assert_eq!(digital_values[0], 0b0011110000010010); // Test all alternating high/low bits
                                                           // Verify CRC
        let calculated_crc = calculate_crc(&data_buffer[..data_buffer.len() - 2]);
        assert_eq!(calculated_crc, data_frame.chk, "CRC mismatch in data frame");
    }
}
